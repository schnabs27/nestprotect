-- ===============================
-- Act page schema + RLS (one file)
-- Safe to run multiple times
-- ===============================

-- 0) ENUM for stage
do $$
begin
  create type act_stage as enum ('Coming','Here');
exception when duplicate_object then null;
end $$;

-- 1) TASKS master table (matches your CSV columns)
create table if not exists act_tasks (
  id uuid primary key default gen_random_uuid(),
  task text not null,
  stage act_stage not null,

  avalanche boolean default false,
  cold      boolean default false,
  earthquake boolean default false,
  flood     boolean default false,
  hail      boolean default false,
  heat      boolean default false,
  hurricane boolean default false,
  ice       boolean default false,
  landslide boolean default false,
  lightning boolean default false,
  tornado   boolean default false,
  tsunami   boolean default false,
  volcanic  boolean default false,
  wildfire  boolean default false,
  wind      boolean default false,
  winter    boolean default false,

  order_num int generated by default as identity,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- 1a) updated_at trigger
create or replace function set_updated_at()
returns trigger language plpgsql as $$
begin
  new.updated_at := now();
  return new;
end $$;

drop trigger if exists trg_act_tasks_updated on act_tasks;
create trigger trg_act_tasks_updated
before update on act_tasks
for each row execute procedure set_updated_at();

-- 2) USER STATE table
create table if not exists act_task_user_state (
  user_id uuid references auth.users(id) on delete cascade,
  task_id uuid references act_tasks(id) on delete cascade,
  is_checked boolean default false,
  updated_at timestamptz default now(),
  primary key (user_id, task_id)
);

-- 3) RLS enable
alter table act_tasks enable row level security;
alter table act_task_user_state enable row level security;

-- 4) POLICIES (drop & recreate for idempotency)

-- act_tasks: readable by web app (anon) and logged-in users; writes blocked for both
drop policy if exists "act_tasks: anon+auth can select" on act_tasks;
create policy "act_tasks: anon+auth can select"
  on act_tasks
  for select
  to anon, authenticated
  using (true);  -- read-only for everyone (service_role bypasses RLS for writes)

-- act_task_user_state: CRUD only for owning user
drop policy if exists "states: user can select own" on act_task_user_state;
create policy "states: user can select own"
  on act_task_user_state
  for select
  to authenticated
  using (auth.uid() = user_id);

drop policy if exists "states: user can insert own" on act_task_user_state;
create policy "states: user can insert own"
  on act_task_user_state
  for insert
  to authenticated
  with check (auth.uid() = user_id);

drop policy if exists "states: user can update own" on act_task_user_state;
create policy "states: user can update own"
  on act_task_user_state
  for update
  to authenticated
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

drop policy if exists "states: user can delete own" on act_task_user_state;
create policy "states: user can delete own"
  on act_task_user_state
  for delete
  to authenticated
  using (auth.uid() = user_id);

-- 5) Optional: ensure anon cannot write anything explicitly
-- (absence of write policies already blocks writes)
revoke all on act_tasks from anon;
revoke all on act_task_user_state from anon;

-- 6) Helpful indexes for filtering
create index if not exists act_tasks_stage_idx on act_tasks(stage);
create index if not exists act_tasks_avalanche_idx on act_tasks(avalanche);
create index if not exists act_tasks_cold_idx      on act_tasks(cold);
create index if not exists act_tasks_earthquake_idx on act_tasks(earthquake);
create index if not exists act_tasks_flood_idx     on act_tasks(flood);
create index if not exists act_tasks_hail_idx      on act_tasks(hail);
create index if not exists act_tasks_heat_idx      on act_tasks(heat);
create index if not exists act_tasks_hurricane_idx on act_tasks(hurricane);
create index if not exists act_tasks_ice_idx       on act_tasks(ice);
create index if not exists act_tasks_landslide_idx on act_tasks(landslide);
create index if not exists act_tasks_lightning_idx on act_tasks(lightning);
create index if not exists act_tasks_tornado_idx   on act_tasks(tornado);
create index if not exists act_tasks_tsunami_idx   on act_tasks(tsunami);
create index if not exists act_tasks_volcanic_idx  on act_tasks(volcanic);
create index if not exists act_tasks_wildfire_idx  on act_tasks(wildfire);
create index if not exists act_tasks_wind_idx      on act_tasks(wind);
create index if not exists act_tasks_winter_idx    on act_tasks(winter);

-- 7) Quick sanity checks (optional)
-- select * from pg_policies where schemaname='public' and table_name in ('act_tasks','act_task_user_state');
